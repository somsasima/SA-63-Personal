'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Router = _interopDefault(require('express-promise-router'));
var express2 = _interopDefault(require('express'));
var fetch = _interopDefault(require('node-fetch'));
var path2 = _interopDefault(require('path'));
var stream = require('stream');
var fs2 = _interopDefault(require('fs'));
var os2 = _interopDefault(require('os'));
var backendCommon = require('@backstage/backend-common');
var fs = _interopDefault(require('fs-extra'));

function getGeneratorKey(entity) {
  if (!entity) {
    throw new Error("No entity provided");
  }
  return "techdocs";
}
async function runDockerContainer({
  imageName,
  args,
  logStream = new stream.PassThrough(),
  docsDir,
  resultDir,
  dockerClient,
  createOptions
}) {
  const [{Error: error, StatusCode: statusCode}] = await dockerClient.run(imageName, args, logStream, {
    Volumes: {
      "/content": {},
      "/result": {}
    },
    WorkingDir: "/content",
    HostConfig: {
      Binds: [`${docsDir}:/content`, `${resultDir}:/result`]
    },
    ...createOptions
  });
  if (error) {
    throw new Error(`Docker failed to run with the following error message: ${error}`);
  }
  if (statusCode !== 0) {
    throw new Error(`Docker container returned a non-zero exit code (${statusCode})`);
  }
  return {error, statusCode};
}

class TechdocsGenerator {
  async run({
    directory,
    logStream,
    dockerClient
  }) {
    const resultDir = fs2.mkdtempSync(path2.join(os2.tmpdir(), `techdocs-tmp-`));
    await runDockerContainer({
      imageName: "spotify/techdocs",
      args: ["build", "-d", "/result"],
      logStream,
      docsDir: directory,
      resultDir,
      dockerClient
    });
    console.log(`[TechDocs]: Successfully generated docs from ${directory} into ${resultDir}`);
    return {resultDir};
  }
}

class Generators {
  constructor() {
    this.generatorMap = new Map();
  }
  register(templaterKey, templater) {
    this.generatorMap.set(templaterKey, templater);
  }
  get(entity) {
    const generatorKey = getGeneratorKey(entity);
    const generator = this.generatorMap.get(generatorKey);
    if (!generator) {
      throw new Error(`No generator registered for entity: "${generatorKey}"`);
    }
    return generator;
  }
}

const parseReferenceAnnotation = (annotationName, entity) => {
  var _a;
  const annotation = (_a = entity.metadata.annotations) == null ? void 0 : _a[annotationName];
  if (!annotation) {
    throw new backendCommon.InputError(`No location annotation provided in entity: ${entity.metadata.name}`);
  }
  const [protocol, location] = annotation.split(/:(.+)/);
  if (!protocol || !location) {
    throw new backendCommon.InputError(`Failure to parse either protocol or location for entity: ${entity.metadata.name}`);
  }
  return {
    protocol,
    location
  };
};

class DirectoryPreparer {
  prepare(entity) {
    const {location: managedByLocation} = parseReferenceAnnotation("backstage.io/managed-by-location", entity);
    const {location: techdocsLocation} = parseReferenceAnnotation("backstage.io/techdocs-ref", entity);
    const managedByLocationDirectory = path2.dirname(managedByLocation);
    return new Promise((resolve) => {
      resolve(path2.resolve(managedByLocationDirectory, techdocsLocation));
    });
  }
}

class Preparers {
  constructor() {
    this.preparerMap = new Map();
  }
  register(protocol, preparer) {
    this.preparerMap.set(protocol, preparer);
  }
  get(entity) {
    const {protocol} = parseReferenceAnnotation("backstage.io/techdocs-ref", entity);
    const preparer = this.preparerMap.get(protocol);
    if (!preparer) {
      throw new Error(`No preparer registered for type: "${protocol}"`);
    }
    return preparer;
  }
}

class LocalPublish {
  publish({
    entity,
    directory
  }) {
    const publishDir = path2.resolve(__dirname, `../../../../static/docs/${entity.metadata.name}`);
    if (!fs.existsSync(publishDir)) {
      fs.mkdirSync(publishDir, {recursive: true});
    }
    return new Promise((resolve, reject) => {
      fs.copy(directory, publishDir, (err) => {
        if (err) {
          reject(err);
        }
        resolve({
          remoteUrl: `http://localhost:7000/techdocs/static/docs/${entity.metadata.name}`
        });
      });
    });
  }
}

async function createRouter({
  preparers,
  generators,
  publisher,
  config: config2,
  dockerClient
}) {
  const router = Router();
  router.get("/", async (_, res) => {
    res.status(200).send("Hello TechDocs Backend");
  });
  router.get("/buildall", async (_, res) => {
    const baseUrl = config2.getString("backend.baseUrl");
    const entitiesResponse = await (await fetch(`${baseUrl}/catalog/entities`)).json();
    const entitiesWithDocs = entitiesResponse.filter((entity) => {
      var _a;
      return (_a = entity.metadata.annotations) == null ? void 0 : _a["backstage.io/techdocs-ref"];
    });
    entitiesWithDocs.forEach(async (entity) => {
      const preparer = preparers.get(entity);
      const generator = generators.get(entity);
      const {resultDir} = await generator.run({
        directory: await preparer.prepare(entity),
        dockerClient
      });
      publisher.publish({
        entity,
        directory: resultDir
      });
    });
    res.send("Successfully generated documentation");
  });
  if (publisher instanceof LocalPublish) {
    router.use("/static/docs/", express2.static(path2.resolve(__dirname, `../../static/docs`)));
  }
  return router;
}

exports.DirectoryPreparer = DirectoryPreparer;
exports.Generators = Generators;
exports.LocalPublish = LocalPublish;
exports.Preparers = Preparers;
exports.TechdocsGenerator = TechdocsGenerator;
exports.createRouter = createRouter;
